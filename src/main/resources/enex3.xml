<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-export SYSTEM "http://xml.evernote.com/pub/evernote-export3.dtd">
<en-export export-date="20170617T195606Z" application="Evernote" version="Evernote Mac 6.11 (454874)">
<note><title>3: Aleksey Fomkin</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd"><en-note><h2><b>Make frontend great again</b></h2><p><b>Data Monsters</b> * <b><i>CTO</i></b></p><p><pre>aleksey.fomkin@gmail.com</pre></p><p><i><pre>@yeblota</pre></i></p><p>Not so long ago we entered the era of one-page web applications (SPA). Very often a server turns into a stupid layer between DBMS and a fat client in the browser. Developers are forced to write tens of thousands of lines of meaningless code. Possible solutions to the problem are web-oriented DBMS (Firebase) or new query languages ​​(GraphQL).  I propose to approach from the other side and return to the idea of ​​a thin client. In my talk, I will tell you about my project - the Korolev, which is make possible to create modern single-page web applications in a functional programming style, in the Scala language, and they will be work on the server side.</p></en-note>]]></content><created>20170616T230554Z</created><updated>20170616T230554Z</updated><tag>40</tag><tag>company-datamonsters</tag><tag>scala</tag><tag>code-live</tag><tag>data-not</tag><note-attributes><reminder-order>0</reminder-order></note-attributes></note>
<note><title>9: Sunil Mallya</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd"><en-note><h2><b>Building model testing infrastructure and scaling AI predictions with AWS Lambda</b></h2><p><b>Amazon Web Services</b> * <b><i>Deep Learning</i></b></p><p><pre>smallya@amazon.com</pre></p><p><i><pre>@sunilmallya</pre></i></p><p>AI model training and validation is just a small part of the story. After the model is built, the real work begins. To service millions of customers seamlessly, every application must scale. In this talk I will showcase how customers can build multi arm bandit strategy to test their models at scale and also scale their prediction pipeline using AWS Lambda.</p></en-note>]]></content><created>20170616T230557Z</created><updated>20170616T230557Z</updated><tag>40</tag><tag>money</tag><tag>data</tag><tag>data-linked</tag><tag>company-amazonwebservices</tag><tag>code-github</tag><note-attributes><reminder-order>0</reminder-order></note-attributes></note>
<note><title>10: Evan Chan</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd"><en-note><h2><b>Building a High-Performance Database with Scala, Akka, and Spark</b></h2><p> * <b><i>Senior Software Engineer</i></b></p><p><pre>velvia@gmail.com</pre></p><p><i><pre>@evanfchan</pre></i></p><p>#distributedsystems #scala #akka #spark #FiloDB #cassandra  Scala and its large ecosystem of libraries are increasingly being used to build highly scalable and performant data systems.  In this talk, I share years of experience building high performance data systems using Scala, Akka, and Spark, plus recent experience building FiloDB, a high performance analytics database built on these technologies.  FiloDB is one of the fastest JVM-based databases, with scan speeds exceeding Apache Parquet on Spark.  How do we balance Scala and functional programming with very high performance demands?   What are some tips to watch out for when building very very fast Scala code?  - The big data landscape and what is missing for enabling streaming applications - FiloDB as a distributed analytical database that handles streaming and updates - FiloDB architecture and distributed message routing - When to use Futures, Actors, Reactive Streams - Using Akka Cluster to coordinate multiple ingestion nodes - Writing a reactive, at-least-once data pipeline with back pressure - Monix and use of reactive streams - Reactive/async tracing and production metrics - Filo: summing integers at billions of ops per second, taking advantage of processor cache and SIMD with super fast vector operations - Serialization, GC, and off-heap: how to leverage binary data structures for the win - JVM method dispatch, inlining, and writing lots of small methods</p></en-note>]]></content><created>20170616T230557Z</created><updated>20170616T230557Z</updated><tag>40</tag><tag>code-slides</tag><tag>data-other</tag><tag>data</tag><tag>scala</tag><note-attributes><reminder-order>0</reminder-order></note-attributes></note>
</en-export>
